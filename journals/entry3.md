## React Pomodoro Journal Entry 3

### Working on the Timer:

Getting the actual timer to work was actually more difficult than I thought. I knew that copying and pasting the functionality of the timer that I had from the Vue version was not going to work properly, but there were quite a few things I needed to change in order to get the timer to work.

In the Vue version, since the majority of the entire project’s code was in one file, I didn’t have to worry about state or variables being used on a more global scale. I knew that for this project that I didn’t want to use a state management tool like Redux, so I had to consider how I was going to get certain variables to work across the different components. I also knew that I wanted to make the timer more modular in the sense that the timer itself wasn’t necessarily the pomodoro timer, but rather it was just a timer that could count down given a time value. I realized in hindsight that the component was probably named incorrectly, but I decided to leave the naming for now.

In trying to get the timer to work, I ran into a lot of issues and tried many different things to get it to work. Rather than going through everything that I tried, I am going to discuss the main issues that I dealt with, and how I ended up implementing the timer.

The first main issue I encountered with the timer was when I copied the timer function code from the Vue version over to this React version. I obviously knew it wouldn’t work right away but I needed to consider how to get my timer to even start. In the Vue version, since everything was in one file, I could have the button easily indicate the start of the timer. Since the button was not a part of the PomodoroTimer component, it was much more difficult to get the timer to actually start. Before I tried to hook up the Button with the PomodoroTimer, I decided to just get the PomodoroTimer to be able to start itself.

The main issue I dealt with when getting the PomodoroTimer to start itself was also with starting and stopping the timer. Initially, I had the timer function with no way to start it. I then called the timer function within a useEffect method to get the timer started. I ran into various issues doing this but the main thing was that it continued to call the timer over and over creating new instances of the timer. What I ended up doing to fix this was having a start boolean state variable that would determine when the timer should be started. When it was true, I would call the timer function to start the timer. I then needed to switch the state of the Boolean variable so that it would not continue to call a new timer. I would switch this state immediately after the timer was started (this was not a good fix). Although this was not a good implementation, it did get the timer to work as I had wanted for the time being.

With this way of approaching the problem, I only had to make minor adjustments to my timer method that I copied from the Vue version. I would run into more issues when I started to attempt at getting the button to start the timer.

### Starting to get the Button to start the Timer:

When thinking about how to get the button to get the timer to start, I considered how I got the button to switch the styles. What I needed to do was to add a way for the handleTimerStatus function to pass down a prop to PomodoroTimer and tell it that it can start.

To get this to work, I created another state variable in Background called timerStart (I later renamed to timerActive). This variable would essentially act like the start variable I had put in PomodoroTimer. Since I now had this timerStart variable, I decided to remove the start variable from PomodoroTimer and just rely on this for that functionality as a passed in prop. The issue I then ran into was that I was again calling the Timer function too many times and now without an easy way to change the prop from Background.

The fix that I had for this issue was honestly just bad. This is a point in the project where hindsight is 20/20, but it served as a good example why allowing bad implementation of code can sometimes comeback to bite you. So, let me explain my implementation and why it was bad (I would later fix it). My fix for the issue of my timer function in PomodoroTimer being called multiple times as a result of the prop passed by the Background component was to create a function within Background that was specifically used to setting that timerStart variable back to false so the timer would not start. Then, within PomodoroTimer, when the timerStart passed in as a prop was seen by the useEvent method as true, it would call the timer function and then call that specific function (which was also passed as a prop to PomodoroTimer from Background) to set timerStart to false so that the timer function would not be re called.

First, let me explain why having the PomodoroTimer function in a way that when a variable is set to true, it calls a variable, and then immediately resets that variable to false is bad code. It is bad code because the timerStart variable is only ever set to true for one instance and then immediately set to false. It defaults to false in order to ensure the timer is not started immediately. When the button is pressed, it is changed to true, the timer function is called, and then it is immediately set to false. I remember that when I was debugging, I would look through the dev tools at what this variable was doing, and when I would click the start button, I couldn’t even see it change from false to true and back to false because it was such an instantaneous change. It basically just looked like the variable was always false. The reason why I consider this bad code is that my Boolean variable was not acting in a way that was actually logical. What I mean by this is that for a timer, if I have a timerStart variable, when it is false it logically makes sense that the timer is not yet started. If it is true, then the timer has started. Well, with this implementation, I had it so that the false state actually represented an instance where the timer was started. In hindsight, a better name for this variable should be timerActive as this naming better represents what this variable should indicate.

The second reason why this implementation was overall bad was that I had a function that was so specific to one particular instance. Obviously, functions are used for specific instances, but the instance that this function was needed was just too specific, and I had a gut feeling when making it that it was unnecessary. It is also an indication that bad code just yields more bad code. If you are ever coding and you are creating a function or a variable that you feel is almost like too specific or unnecessary, it is a good idea to review if there may be a better way to implement an aspect of code that the function or variable relies on.

In hindsight, I knew when I was writing the code that this was a bad implementation. Even though it worked, I should have taken the time to consider a better implementation before moving on. As I will discuss in the next journal entry, this implementation ended up causing more headaches and I ended up having to change it anyway. If I could, I would have fixed the implementation first before moving on to working on other functionality of the project.
